function imputed_data = SeqkNNv2(data, K, traindata)
% SeqKNN: Sequential KNN imputation method
% This function estimates missing values sequentially from the gene that has
% least missing rate in microarray data, using weighted mean of k nearest neighbors.
%
% <Usage>
% imputed_data=SeqKNN(data, k, traindata);
%
% <Arguments>
% data: matrix or dataframe, 1 row corresponds to 1 gene, 1 column to 1
% sample, colnames and rownames can be used
% K: number of nearest neighbors
% traindata: (optional) training data to use when all rows in data have missing values
%
% <Details>
% SeqKNN separates the dataset into incomplete and complete sets that have
% or have not missing values, respectively. 
% The genes in incomplete set are imputed by the order of missing rate. Missing value
% is filled by the weighted mean value of corresponding column of the nearest neighbor genes in
% complete set. Once all missing values in a gene are imputed, the imputed gene is moved into the
% complete set and used for the imputation of the rest of genes in incomplete set.

imputed_data = zeros(size(data));
complete = [];
incomplete = [];
missing = [];
com_ind = [];
incom_ind = [];
[rows, cols] = size(data);

for i = 1:rows
    if ~any(isnan(data(i,:)))
        complete = [complete; data(i,:)];
        com_ind = [com_ind, i];
    else
        incomplete = [incomplete; data(i,:)];
        incom_ind = [incom_ind, i];
        missing = [missing, sum(isnan(data(i,:)))];
    end
end

% Fallback imputation for completely missing rows if no complete rows are available
if isempty(complete) || exist('traindata', 'var')
    if exist('traindata', 'var') && ~sum(isnan(traindata(:)))
        complete = traindata;
    else
        % Check if there is at least one complete row
        % Use column-wise mean of the current dataset
        meanValues = repmat(nm_nanmean(data), rows, 1);
        % Replace NaNs with column-wise means
        idx = isnan(data);
        complete = data;
        complete(idx) = meanValues(idx);
    end
end
imputed_data(com_ind,:) = data(com_ind,:);
[~, missing_order] = sort(missing);
completedata = complete;

% before you start the KNN loop:
if exist('traindata','var') && ~any(isnan(traindata(:)))
  globalMeans = nm_nanmean(traindata, 1);
else
  globalMeans = nm_nanmean(data, 1);
end

% Part 2: Impute missing values
for j = 1:size(incomplete,1)
    fprintf('.');
    dist = [];
    cgen = size(completedata, 1);
    r = missing_order(j);
    for i = 1:cgen
        % Calculate distance, handling NaNs appropriately
        dist(i) = nm_nansum((incomplete(r,:) - completedata(i,:)).^2);
    end
    [dist, pos] = sort(dist);
    pos = pos(1:K);
    dist = dist(1:K);
    dist(dist == 0) = realmin; % Avoid division by zero
    weights = (1./dist) ./ sum(1./dist);
    for g = 1:cols
        if isnan(incomplete(r, g))
            vals = completedata(pos, g);      % K×1
            good = ~isnan(vals);
            if any(good)
              % renormalize to sum to 1 over only the "good" neighbors
              w_good = weights(good) ./ sum(weights(good));
              incomplete(r,g) = sum(w_good .* vals(good));
            else
              % last‐resort fallback — e.g. the global column mean
              incomplete(r,g) = globalMeans(g);
            end
        end
    end
    completedata = [completedata; incomplete(r,:)];
end

imputed_data(incom_ind,:) = incomplete;
end